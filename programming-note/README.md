# 编程的思考

## 事件机制

* 触发事件的地方能不能拿到事件的函数体和事件的返回值？
  * 如果事件绑定的函数是单个，几乎等同于直接调用目标函数
  * 如果事件绑定的函数是多个，等同于循环调用这些目标函数，也可以以数组的方式返回这些函数的返回值

* 相比直接调用函数，事件机制相当于一种代码组织方式，可以方便的在关键的地方增删代码
* 事件机制有点类似泛型的概念，均是定义时不知道要做什么，调用时才知道做什么。

## 如何保持数据一致性

* 一致性(Consistency) 需求，强调事务执行的前后，数据的状态满足预定的约束。如转账前后，转账双方钱的总数不发生变化。  
  * 具体实现 事务执行完成后需要业务代码验证，然后决定回滚和提交。
* 原子性(Atomicity) 实现，事务是不可分割的工作单位，只有成功和失败状态，没有中间状态。
  * 具体实现 回滚日志(undo log) 记录每一个操作，每一个操作都有一个对应的反操作，如果失败或回滚就从失败处执行反操作。
* 隔离性(Isolation) 实现，事务不可以并发执行，只能顺序执行。
  * 具体实现 锁
* 持久性(Durability) 实现，事务提交后数据写入持久存储。
  * 具体实现 通过把操作追加写入独立的磁盘文件(redo log，相当于队列)中，避免频繁的磁盘读写。

* 参考 [一文解析：MySQL事务ACID原理让你面试不再害怕](https://zhuanlan.zhihu.com/p/65438009)

## 范式

* [介绍命令式编程](http://codenugget.co/2015/03/05/declarative-vs-imperative-programming-web.html)
  * [login demo](https://jsfiddle.net/b00gizm/f011j2qo/1/)

## 异步操作

* 异步操作的实现方式
  * 回调函数传参
  * 事件监听、管理
  * promise，thenable
  * await/async 推荐的方式
  * co库 使用yield

* 异步操作的实现的共同点
  * 提前注册好函数，延迟执行（在需要的时候调用）

* 异步操作中遇到的问题
  * 由于网络延迟影响，收到数据的次序与发出次序不符

* 回调函数是一种简单、易于理解的实现异步的方法
* 且回调间的嵌套过多导致代码不可读，复用困难
* 回调函数的问题是不知道回调函数什么时候被执行，代码之间有产生了耦合。

## 性能

* 防抖 指定时间内没有调用后开始运行
* 节流 指定时间内多次调用记为一次运行

* 如果从非纯函数的角度理解，**对返回值的要求**和**函数中对外部数据的操作**构成了我们的**需求**。
  * 关于操作的定义。
    * 打印日志，改变外部控制台输出了信息，人也应该理解为是外部的一环
    * 如删除某个外部数组（包括传入参数）的元素

* 从纯函数的角度理解，**对返回值的要求**就是我们的**需求**。
  * **返回值的要求不同说明需求不同**
  * 纯函数不应该有任何对外部数据的操作，即不能有改变传入参数和全局变量的动作。
    * 如果是返回后再将返回值进行打印不属于函数中的操作
  * 纯函数的好处是:**需求是显而易见的**。
  * 纯函数是有局限性的，链式调用是非纯函数的应用。

* 同一个需求可以有不同的实现，不同的实现就会有差异，比如说步骤数量、运行时长
* 同一个实现加以微调和改动，又可以用到不同的需求上，即修改一下返回值
* 需求不同时，实现很可能也是不同的，如果对比不同需求的实现谁运行更快或者更慢，这种比较条件不唯一，是不具有意义的
* 只有在返回值明确的时候才能找到性能最优解，要**结合实际需求出发找到的性能最优解才是有意义的**。
